<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-03-02T23:25:24-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jeremy Grosser</title><subtitle>Hacks and slashes</subtitle><entry><title type="html">Using drivers</title><link href="http://localhost:4000/ada/pico/2021/03/02/using-drivers.html" rel="alternate" type="text/html" title="Using drivers" /><published>2021-03-02T18:38:00-08:00</published><updated>2021-03-02T18:38:00-08:00</updated><id>http://localhost:4000/ada/pico/2021/03/02/using-drivers</id><content type="html" xml:base="http://localhost:4000/ada/pico/2021/03/02/using-drivers.html">&lt;p&gt;Twiddling bits in registers doesn’t make the most intuitive, readable, or portable code. This is why we write drivers. I’ve created three &lt;a href=&quot;https://alire.ada.dev/&quot;&gt;Alire&lt;/a&gt; packages, &lt;a href=&quot;https://github.com/JeremyGrosser/rp2040_hal&quot;&gt;rp2040_hal&lt;/a&gt;, &lt;a href=&quot;https://github.com/JeremyGrosser/pico_bsp&quot;&gt;pico_bsp&lt;/a&gt;, and &lt;a href=&quot;https://github.com/JeremyGrosser/pico_examples&quot;&gt;pico_examples&lt;/a&gt;. rp2040_hal contains all of the drivers for the chip’s internal peripherals, pico_bsp contains some details about the Pico board and drivers for the Pimoroni Pico addons, and pico_examples contains, you guessed it, example code. At the moment, pico_bsp cannot be used with the Ravenscar runtime without modification, so I’ll ignore that and focus on rp2040_hal for right now. The examples repository contains lots of code that uses the pico_bsp if you’d like to see how that works.&lt;/p&gt;

&lt;p&gt;Now that I have drivers, I’ve removed all of the interfaces generated from SVD from our project. These still live in the rp2040_hal package but as long as the drivers implement all of the right interfaces, we shouldn’t need them. If you find something you can’t do with the HAL drivers that seems important, please send a pull request to the rp2040_hal repo. I’ve refrained from tagging a 1.0 release because I’m still not satisfied with all of the interfaces and retain the right to break the API.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;kn&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Ada&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Real_Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ada&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Real_Time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;RP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;GPIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LED&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_Point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;LED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Configure&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;LED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Toggle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seconds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can see that the Main procedure is much more compact and readable now. The PADS_BANK and IO_BANK stuff is wrapped up in a lovely Configure interface and the GPIO is abstracted into an object with a very convenient Toggle method.&lt;/p&gt;

&lt;p&gt;Building the code is done using Alire now, rather than calling gprbuild directly. Alire is analogous to Rust’s Cargo or Python’s pip. Alire keeps track of all of the dependencies and can pull in new ones with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;alr with&lt;/code&gt; command. At the time of writing, the rp2040_hal package isn’t available in the Alire index yet, you can clone it manually and pin the dependency.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/JeremyGrosser/rp2040_hal
cd 04-hal-blink
alr pin --use=../rp2040_hal rp2040_hal
alr build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JeremyGrosser/pico_examples/blob/master/blog/04-hal-blink/src/main.adb&quot;&gt;Source code&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="ada" /><category term="pico" /><summary type="html">Twiddling bits in registers doesn’t make the most intuitive, readable, or portable code. This is why we write drivers. I’ve created three Alire packages, rp2040_hal, pico_bsp, and pico_examples. rp2040_hal contains all of the drivers for the chip’s internal peripherals, pico_bsp contains some details about the Pico board and drivers for the Pimoroni Pico addons, and pico_examples contains, you guessed it, example code. At the moment, pico_bsp cannot be used with the Ravenscar runtime without modification, so I’ll ignore that and focus on rp2040_hal for right now. The examples repository contains lots of code that uses the pico_bsp if you’d like to see how that works.</summary></entry><entry><title type="html">Abstractions and Runtimes</title><link href="http://localhost:4000/ada/pico/2021/03/02/abstractions-and-runtimes.html" rel="alternate" type="text/html" title="Abstractions and Runtimes" /><published>2021-03-02T18:37:00-08:00</published><updated>2021-03-02T18:37:00-08:00</updated><id>http://localhost:4000/ada/pico/2021/03/02/abstractions-and-runtimes</id><content type="html" xml:base="http://localhost:4000/ada/pico/2021/03/02/abstractions-and-runtimes.html">&lt;p&gt;A month later, much has happened! I’ve implemented drivers for nearly all of the RP2040’s peripherals, &lt;a href=&quot;https://github.com/Fabien-Chouteau&quot;&gt;Fabien Chouteau&lt;/a&gt; contributed an I2C driver, and &lt;a href=&quot;https://github.com/damaki&quot;&gt;Daniel King&lt;/a&gt; has ported bb-runtimes, including multiprocessing support. Let’s get that blink example updated!&lt;/p&gt;

&lt;p&gt;There are lots of pieces that can be abstracted away and made more flexible. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ticks&lt;/code&gt; shouldn’t be a public variable that can be modified from anywhere. I should also define a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt; type to differentiate it from other Integers. If you follow these changes to their logical conclusion, you get something that looks like &lt;a href=&quot;http://ada-auth.org/standards/12rm/html/RM-D-8.html&quot;&gt;Ada.Real_Time&lt;/a&gt; which already exists in the Ravenscar runtimes.&lt;/p&gt;

&lt;p&gt;The Ada language provides some fairly high level constructs related to tasking, memory management, and timing that aren’t easy or practical to implement on every platform and the use of some of those features may violate a project’s certification requirements. For this reason, there several runtime profiles with varying levels of functionality. So far, I’ve been using a Zero Footprint (ZFP) runtime, which provides only the bare minimum to allocate some stack space, pass arguments, and call a procedure. No batteries included. The next step up would be the &lt;a href=&quot;http://ada-auth.org/standards/12rm/html/RM-D-13.html&quot;&gt;Ravenscar&lt;/a&gt; profile, which allows a broader set of builtin functionality, including tasking and synchronization constructs you’d expect to find in an RTOS. An open source implementation of Ravenscar is available in the &lt;a href=&quot;https://github.com/AdaCore/bb-runtimes&quot;&gt;bb-runtimes&lt;/a&gt; repository, though porting it to a new chip is not a small task. There are other runtime implementations that wrap existing RTOS libraries like &lt;a href=&quot;https://github.com/simonjwright/cortex-gnat-rts&quot;&gt;FreeRTOS&lt;/a&gt; and &lt;a href=&quot;https://devel.rtems.org/wiki/TBR/UserManual/RTEMSAda&quot;&gt;RTEMS&lt;/a&gt;. GNAT GCC also includes runtimes for Linux, FreeBSD, Solaris, HP-UX, VxWorks, LynxOS, QNX, and Windows that implement the full set of libraries in the Ada language specification.&lt;/p&gt;

&lt;p&gt;I’ll port our blink example to a Ravenscar RTS (Run-Time System) from bb-runtimes. As the RP2040 is still a new platform, its runtimes haven’t been merged yet and aren’t distributed in the GNAT Community 2020 bundle so I’ll need to build it from source.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JeremyGrosser/pico_examples/blob/master/blog/02-ravenscar-blink/src/main.adb&quot;&gt;02-ravenscar-blink&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone -b rpi-pico https://github.com/damaki/bb-runtimes
cd bb-runtimes
./build_rts.py --build rpi-pico-mp
cd ../02-ravenscar-blink
gprbuild -P rpsimple.gpr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You’ll notice that the boot2, crt0, and linker script aren’t needed anymore as they’re included with the runtime. I’ve replaced all of the SysTick stuff with a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay 1.0;&lt;/code&gt; statement. The RTS has configured the PLLs and the TIMER peripheral, so I now have microsecond resolution tickless operation. We can still do better! The single-cycle loop still takes time to execute, and waking from sleep takes a few cycles too, so the delay between blinks is still not precisely one second.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/JeremyGrosser/pico_examples/blob/master/blog/03-realtime-blink/src/main.adb&quot;&gt;03-realtime-blink&lt;/a&gt; I’ve imported &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ada.Real_Time&lt;/code&gt; and declared a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next_Blink&lt;/code&gt; variable with type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt;. Time is a private type as the storage representation of time is a non-portable implementation detail. Initializing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next_Blink&lt;/code&gt; with a call to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clock&lt;/code&gt; function means that time doesn’t even have to start at 0!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now that I know when the next blink should happen, I can use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay until&lt;/code&gt; statement for precision waiting.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Seconds&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JeremyGrosser/pico_examples/blob/master/blog/03-realtime-blink/src/main.adb&quot;&gt;Source code&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="ada" /><category term="pico" /><summary type="html">A month later, much has happened! I’ve implemented drivers for nearly all of the RP2040’s peripherals, Fabien Chouteau contributed an I2C driver, and Daniel King has ported bb-runtimes, including multiprocessing support. Let’s get that blink example updated!</summary></entry><entry><title type="html">From Zero to Blinky in Ada</title><link href="http://localhost:4000/ada/pico/2021/03/02/from-zero-to-blinky-ada.html" rel="alternate" type="text/html" title="From Zero to Blinky in Ada" /><published>2021-03-02T18:36:00-08:00</published><updated>2021-03-02T18:36:00-08:00</updated><id>http://localhost:4000/ada/pico/2021/03/02/from-zero-to-blinky-ada</id><content type="html" xml:base="http://localhost:4000/ada/pico/2021/03/02/from-zero-to-blinky-ada.html">&lt;p&gt;Recently, the Raspberry Pi Foundation launched their new &lt;a href=&quot;https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf&quot;&gt;RP2040 SoC&lt;/a&gt; on a $4 development board called &lt;a href=&quot;https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf&quot;&gt;Pico&lt;/a&gt;. As the foundation’s goal is primarily education, they’ve provided lots of high quality documentation, libraries, and examples for the new chip. Naturally, I’m going to ignore most of that and roll my own. Why? Because this is my idea of fun and I’m trapped inside during a pandemic.&lt;/p&gt;

&lt;p&gt;If you’d like to build the examples and follow along, you’ll need &lt;a href=&quot;https://www.adacore.com/download&quot;&gt;GNAT Community 2020 ARM ELF&lt;/a&gt; installed in your PATH. I’ve only tested this on x86_64 Debian, if you’re on another platform I can’t help you. You’ll also want an SWD debugger that works with the RP2040. I use openocd on a Raspberry Pi, I hear Segger J-Link support is coming soon. Technically you could use elf2uf2 and load binaries over USB, but that’s gonna get tedious for any nontrivial debugging.&lt;/p&gt;

&lt;p&gt;The RP2040 has no internal flash. The boot ROM loads 256 bytes of code from an external SPI flash and executes it. This “second stage bootloader” is expected to configure the XIP (eXecute In Place) peripheral with clock and timing details specific to the flash chip in use, then jump to the start of the user code in the memory mapped to the flash.&lt;/p&gt;

&lt;p&gt;I tried to rewrite the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot2.S&lt;/code&gt; bootloader from pico-sdk in Ada, but I couldn’t get it to fit inside 256 bytes. It might be possible, but not today. I ran gcc’s preprocessor on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot2.S&lt;/code&gt; to generate a single assembly file I could link. I copied the linker script and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crt0.S&lt;/code&gt; from pico-sdk too.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zfp-cortex-m0p&lt;/code&gt; Ada runtime does most of the boilerplate Cortex-M0+ setup and implements &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ada.Text_IO&lt;/code&gt; with semihosting over the debug interface, so I wrote a hello world and copypasta’d a GPR project file to build it.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;kn&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Ada&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;Text_IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ada&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Text_IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Put_Line&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Hello, RP2040!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It took me a few hours to figure out the right incantation to get the linker to put the .boot2 section at the start of the flash chip along with crt0.S and the Ada runtime’s init code. The result is an ugly mess, which is why I’m omitting it here. If you want to see how to do things the quick and dirty way, &lt;a href=&quot;https://github.com/JeremyGrosser/rp/tree/744e546999aba596701dcf89d4f5e39f056932e0&quot;&gt;my initial attempt is on github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I soldered some headers for the Pico’s SWD port, wired it to a Raspberry Pi 4, and compiled the &lt;a href=&quot;https://github.com/raspberrypi/openocd/tree/rp2040&quot;&gt;raspberrypi branch of openocd&lt;/a&gt;. As far as I can tell, nobody distributes a toolchain that can cross-compile Ada arm-eabi binaries on aarch64 and I don’t want to spend my time building binutils and gcc right now, so I setup an ssh tunnel from my x86_64 workstation to the Pi. I run arm-eabi-gdb locally and connect to openocd over the tunnel. Most of this will go in a .gdbinit script later.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/raspberrypi-swd.png&quot; alt=&quot;Raspberry Pi SWD wiring&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh pi@192.168.1.202 -L3333:localhost:3333
openocd -f interface/raspberrypi-swd.cfg -f target/rp2040.cfg

arm-eabi-gdb obj/main
target extended-remote localhost:3333
monitor arm semihosting enable
load
run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s write some code! For this example, I’m not going to do anything particularly complicated or idiomatic to Ada in order to keep things as simple as possible. This is going to be a very imperative program assigning values to registers and not much more.&lt;/p&gt;

&lt;p&gt;ARM’s tooling for silicon vendors generates an SVD file, which is a pile of XML that lists all of the peripheral addresses and register offsets with vaguely human readable names. The svd2ada program translates this into Ada spec files with record types and representation clauses. Unfortunately, it crashed with the RP2040 SVD file. svd2ada expects a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;size&amp;gt;&lt;/code&gt; to be specified on every register but the RP2040 SVD defines &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;size&amp;gt;&lt;/code&gt; at the peripheral level. The SVD format says this should then be inherited by the registers in the peripheral, but svd2ada doesn’t do that. I couldn’t figure out how to fix svd2ada so I wrote a quick Python script to modify the SVD file by copying the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;size&amp;gt;&lt;/code&gt; field to every register within a peripheral. Now svd2ada works and generates a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.ads&lt;/code&gt; file for each peripheral on the RP2040.&lt;/p&gt;

&lt;p&gt;Normally the next step in bringing up a new chip would be to get all of the clocks configured, which is usually pretty boring code to write. At startup, the RP2040’s system clock runs from an internal ring oscillator with a not at all predictable or stable frequency between 1.8 and 12 MHz, which is good enough for some blinking. I skipped clock configuration and went straight for the GPIO.&lt;/p&gt;

&lt;p&gt;There are four peripherals that need to be configured to toggle a pin: RESETS, PADS_BANK, IO_BANK, and SIO. RESETS, as you might expect, controls the reset state of the other peripherals. I pull the IO_BANK and PADS_BANK out of reset and wait for any initialization these peripherals might need to do in a busy loop.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;n&quot;&gt;RESETS_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RESET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_bank0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RESETS_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RESET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pads_bank0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESETS_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RESET_DONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_bank0&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RESETS_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RESET_DONE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pads_bank0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Next, PADS_BANK enables the output driver on GPIO25, which is connected to the LED on the Pico board.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;c1&quot;&gt;--  output disable off&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PADS_BANK0_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;--  input enable off&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PADS_BANK0_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;IO_BANK selects a peripheral to connect the pad to.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;c1&quot;&gt;--  function select&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;IO_BANK0_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO25_CTRL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FUNCSEL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sio_25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The SIO (single-cycle IO) peripheral can toggle pins. I added a Pin_Mask constant in the declare block with bit 25 set. svd2ada generates nice subtype definitions for each register field so that I don’t need to know that GPIO_OUT is 30 bits wide. The immediate value here is just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift_Left (1, 25)&lt;/code&gt;, but using Shift_Left here would require some type conversion that I want to avoid in this example.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constant&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GPIO_OUT_GPIO_OUT_Field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;16#0200_0000#&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Enable the output in the SIO peripheral&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;c1&quot;&gt;-- output enable&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OE_SET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OE_SET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now we blink!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_SET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_SET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_CLR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_CLR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Assuming those calls actually get compiled into single cycle writes, that’s gonna be blinking at half the system clock frequency, far faster than the human eye can see, but good enough for an oscilloscope. The SIO peripheral has an XOR register that allows us to make this code even shorter.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;This is where the narrative diverges from reality. After I got to this point, I spent a few days refactoring the code into a package with well defined types and interfaces that conform to the Ada HAL package. For the sake of this example, I’m going to gloss over some of those organizational details and pretend things are still mostly happening in a single Main procedure.&lt;/p&gt;

&lt;p&gt;Next I need a delay in that loop to blink at a rate that’s perceptible to humans. I could call a bunch of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; instructions and waste cycles, but that’s just silly. The RP2040 has a very nice 64-bit timer peripheral that I completely ignored because the chip also has the standard ARM SysTick peripheral that I’m already familiar with. Exported symbols need to be defined at the package level, so I’ve put this code into a SysTick package. I’ve only reproduced the implementation bits here, just know that this is happening in a new file.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;c1&quot;&gt;--  Reload every 1ms&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;PPB_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYST_RVR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RELOAD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SYST_RVR_RELOAD_Field&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12_000_000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;PPB_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SYST_CSR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CLKSOURCE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;--  cpu clock&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;TICKINT&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;ENABLE&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;others&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I need an interrupt handler to increment a counter for every tick. crt0.S exports a weak &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isr_systick&lt;/code&gt; symbol that I can implement.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;n&quot;&gt;Ticks&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Natural&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SysTick_Handler&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Export&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;Convention&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;External_Name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;isr_systick&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SysTick_Handler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Ticks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ticks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SysTick_Handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;I’ll also add a wrapper around the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wfi&lt;/code&gt; (wait for interrupt) assembly instruction in the same package&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;kd&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Machine_Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Asm&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;wfi&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Volatile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Back in the blink loop, I call the wait for interrupt instruction and check the value of Ticks.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ada&quot; data-lang=&quot;ada&quot;&gt;&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ticks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;SIO_Periph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GPIO_OUT_XOR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pin_Mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Next_Blink&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1_000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;SysTick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;IT BLINKS! Not precisely at 1 Hz, as the ring oscillator isn’t accurate, but close enough for this demo.&lt;/p&gt;</content><author><name></name></author><category term="ada" /><category term="pico" /><summary type="html">Recently, the Raspberry Pi Foundation launched their new RP2040 SoC on a $4 development board called Pico. As the foundation’s goal is primarily education, they’ve provided lots of high quality documentation, libraries, and examples for the new chip. Naturally, I’m going to ignore most of that and roll my own. Why? Because this is my idea of fun and I’m trapped inside during a pandemic.</summary></entry></feed>